<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础杂谈 | Abyss</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/assets/img/favicon.ico">
    <meta name="description" content="Abyss&#39;s blog">
    <link rel="preload" href="/assets/js/vendor.vue.8c2dfada.js" as="script"><link rel="preload" href="/assets/css/1.styles.6d048c9e.css" as="style"><link rel="preload" href="/assets/js/vendor.commons.6d048c9e.js" as="script"><link rel="preload" href="/assets/css/styles.33c1ef9e.css" as="style"><link rel="preload" href="/assets/js/app.33c1ef9e.js" as="script"><link rel="preload" href="/assets/css/8.styles.49c1931d.css" as="style"><link rel="preload" href="/assets/js/8.49c1931d.js" as="script"><link rel="preload" href="/assets/js/18.51cabdfa.js" as="script"><link rel="prefetch" href="/assets/css/0.styles.9d2a2822.css"><link rel="prefetch" href="/assets/css/4.styles.c6c31e98.css"><link rel="prefetch" href="/assets/css/5.styles.4eb26167.css"><link rel="prefetch" href="/assets/css/6.styles.b12328b4.css"><link rel="prefetch" href="/assets/css/7.styles.efe9eb71.css"><link rel="prefetch" href="/assets/js/0.9d2a2822.js"><link rel="prefetch" href="/assets/js/10.a9dc25e5.js"><link rel="prefetch" href="/assets/js/11.00369fa9.js"><link rel="prefetch" href="/assets/js/12.ea10e35f.js"><link rel="prefetch" href="/assets/js/13.a06eb5f4.js"><link rel="prefetch" href="/assets/js/14.b8261236.js"><link rel="prefetch" href="/assets/js/15.b9ace423.js"><link rel="prefetch" href="/assets/js/16.5a5b8cc5.js"><link rel="prefetch" href="/assets/js/17.17f2e0ee.js"><link rel="prefetch" href="/assets/js/19.b793f115.js"><link rel="prefetch" href="/assets/js/20.88ebd830.js"><link rel="prefetch" href="/assets/js/21.1e063384.js"><link rel="prefetch" href="/assets/js/22.f2dc7b40.js"><link rel="prefetch" href="/assets/js/23.1debcb1d.js"><link rel="prefetch" href="/assets/js/24.bd3124d6.js"><link rel="prefetch" href="/assets/js/25.cededf34.js"><link rel="prefetch" href="/assets/js/26.ba33d80e.js"><link rel="prefetch" href="/assets/js/27.69b99307.js"><link rel="prefetch" href="/assets/js/28.3c591772.js"><link rel="prefetch" href="/assets/js/29.d53afd48.js"><link rel="prefetch" href="/assets/js/30.c3c2f0cc.js"><link rel="prefetch" href="/assets/js/31.8e5767fd.js"><link rel="prefetch" href="/assets/js/32.6963e79e.js"><link rel="prefetch" href="/assets/js/33.ae19a8db.js"><link rel="prefetch" href="/assets/js/34.c00ad780.js"><link rel="prefetch" href="/assets/js/35.21e5fed2.js"><link rel="prefetch" href="/assets/js/36.c5ff7947.js"><link rel="prefetch" href="/assets/js/37.42d66982.js"><link rel="prefetch" href="/assets/js/4.c6c31e98.js"><link rel="prefetch" href="/assets/js/5.4eb26167.js"><link rel="prefetch" href="/assets/js/6.b12328b4.js"><link rel="prefetch" href="/assets/js/7.efe9eb71.js"><link rel="prefetch" href="/assets/js/9.4c13e2c6.js">
    <link rel="stylesheet" href="/assets/css/1.styles.6d048c9e.css"><link rel="stylesheet" href="/assets/css/styles.33c1ef9e.css"><link rel="stylesheet" href="/assets/css/8.styles.49c1931d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/assets/img/header-image-01.jpg);" data-v-3054f967><div data-v-eab05d90 data-v-3054f967><nav class="navbar" data-v-eab05d90><div class="container" data-v-eab05d90><a href="/" class="router-link-active" data-v-eab05d90><span class="navbar-site-name" data-v-eab05d90>
          Abyss
        </span></a> <div class="navbar-toggler" data-v-eab05d90><svg class="icon" style="font-size:1.2em;" data-v-eab05d90 data-v-eab05d90><title data-v-eab05d90 data-v-eab05d90>menu</title><use xlink:href="#icon-menu" data-v-eab05d90 data-v-eab05d90></use></svg></div> <div class="navbar-links" data-v-eab05d90><a href="/" class="navbar-link" data-v-eab05d90>
            Home
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-eab05d90>
            Posts
          </a><a href="/about/" class="navbar-link" data-v-eab05d90>
            About
          </a><a href="https://github.com/wangxye/wangxye.github.io" target="_blank" rel="noopener noreferrer" class="navbar-link" data-v-eab05d90><span data-v-eab05d90>Github</span> <span data-v-eab05d90><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-eab05d90></div></div> <div class="banner" data-v-66d98992 data-v-3054f967 data-v-3054f967><div class="container" data-v-66d98992><div class="center" data-v-66d98992><h1 data-v-66d98992 data-v-3054f967>
          Java基础杂谈
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-41e4f7f8 data-v-41e4f7f8><main class="main" data-v-41e4f7f8><div class="post" data-v-41e4f7f8 data-v-41e4f7f8><section class="post-meta main-div" data-v-cae733bc><section class="post-date clearfix" data-v-cae733bc><span class="create-date" data-v-cae733bc>
        Created : 2022-01-15
      </span> <!----> <br data-v-cae733bc></section> <section class="post-links" data-v-cae733bc><a href="/posts/2022/01/15/computer-network.html" class="post-link" data-v-cae733bc>
        Previous Post : Computer Network
      </a> <a href="/posts/2022/01/15/os.html" class="post-link" data-v-cae733bc>
        Next Post : 操作系统基础杂谈
      </a></section></section> <article class="main-div"><span id="busuanzi_container_page_pv">
		Page view : <span id="busuanzi_value_page_pv"></span></span> <div class="post-content content content__default"><h1 id="jvm"><a href="#jvm" class="header-anchor">#</a> JVM</h1> <h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="header-anchor">#</a> 垃圾回收算法</h2> <p>简述标记清除算法、标记整理算法和标记复制算法</p> <p>标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。</p> <p>标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存</p> <p>标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。</p> <p>分代收集的原因：在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p> <p><strong>堆内存常见分配策略：</strong></p> <ul><li>对象优先在eden区分配；</li> <li>大对象直接进入老年代；</li> <li>长期存活的对象将进入老年代；
<ul><li>对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</li></ul></li> <li>动态对象年龄判定
<ul><li>当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%），取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值</li></ul></li> <li>空间分配担保，为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</li></ul> <blockquote><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次  Full GC。</p> <p>JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC</p></blockquote> <p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p> <p>部分收集 (Partial GC)：</p> <ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li> <li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li> <li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul> <p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p> <p><strong>对象死亡判定方法：</strong></p> <ul><li>引用计数法，<strong>实现简单，效率高，但很难解决对象之间相互循环引用的问题</strong></li> <li>可达性分析算法，通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。
<ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li> <li>本地方法栈(Native 方法)中引用的对象</li> <li>方法区中类静态属性引用的对象</li> <li>方法区中常量引用的对象</li> <li>所有被同步锁持有的对象</li></ul></li></ul> <p><strong>不可达对象并非&quot;非死不可&quot;：</strong></p> <p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p> <p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p> <p>Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p> <ul><li><strong>强引用</strong>，当内存空间不足，Java 虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</li> <li><strong>软引用</strong>，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。软引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</li> <li><strong>弱引用</strong>，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引用可以和一个引用队列（<code>ReferenceQueue</code>）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li> <li><strong>虚引用</strong>，<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。 虚引用必须和引用队列（<code>ReferenceQueue</code>）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</li></ul> <p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（<code>OutOfMemory</code>）等问题的产生</strong>。</p> <p>判定一个常量废弃的原则：</p> <blockquote><p><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></p> <p><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</p> <p><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p></blockquote> <p>判断一个类无用：</p> <ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li> <li>加载该类的 <code>ClassLoader</code> 已经被回收。</li> <li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul> <p><strong>垃圾收集器：</strong></p> <ul><li>Serial 收集器，<strong>单线程</strong>，只会使用一条垃圾收集线程去完成垃圾收集工作，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>&quot;Stop The World&quot;</strong> ），直到它收集结束。
<ul><li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></li> <li><strong>简单而高效（与其他收集器的单线程相比）</strong></li> <li>多用于在 Client 模式</li></ul></li> <li>Par New 收集器，<strong>多线程</strong>，<strong>除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong> <ul><li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></li> <li>多用于 Server 模式下</li> <li>除了 Serial 收集器外，只有它能与 CMS 收集器配合工作</li></ul></li> <li>Parallel Scavenge 收集器，<strong>关注点是吞吐量（高效率的利用 CPU）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> <ul><li><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></li> <li>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old</li></ul></li> <li>Serial Old 收集器，<strong>Serial 收集器的老年代版本</strong> <ul><li>一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用</li> <li>另一种用途是作为 CMS 收集器的后备方案。</li></ul></li> <li>Parallel Old 收集器，**Parallel Scavenge 收集器的老年代版本。**多线程和“标记-整理”算法。</li> <li>CMS 收集器，<strong>以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong> <ul><li><strong>“标记-清除”算法</strong></li> <li>步骤：
<ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li> <li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li> <li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li> <li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul></li> <li>主要优点：<strong>并发收集、低停顿</strong>。</li> <li>三个明显的缺点：
<ul><li><strong>对 CPU 资源敏感；</strong></li> <li><strong>无法处理浮动垃圾；</strong></li> <li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul></li></ul></li> <li>G1 收集器，<strong>一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong> <ul><li>特点：
<ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li> <li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li> <li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li> <li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul></li> <li>步骤
<ul><li><strong>初始标记</strong></li> <li><strong>并发标记</strong></li> <li><strong>最终标记</strong></li> <li><strong>筛选回收</strong></li></ul></li> <li><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</li></ul></li> <li>ZGC 收集器，与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。在 ZGC 中出现 Stop The World 的情况会更少！</li></ul> <h2 id="synchronized-锁优化"><a href="#synchronized-锁优化" class="header-anchor">#</a> synchronized 锁优化</h2> <p>JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但是两者的实现细节不一样。</p> <ol><li>代码块同步：通过使用 monitorenter 和 monitorexit 指令实现的</li> <li>同步方法：ACC_SYNCHRONIZED 修饰</li></ol> <p>在 HotSpot 虚拟机中，对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充。</p> <p>对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。</p> <p>多线程下 synchronized 的加锁就是对同一个对象的对象头中的 MarkWord 中的变量进行CAS操作。</p> <p>锁的升级过程可分为如下：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p> <p><strong>1、偏向锁</strong>是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。</p> <p>假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。</p> <blockquote><p>为什么要这样做呢？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。</p></blockquote> <p>如果支持偏向锁（没有计算 hashCode），那么在分配对象时，分配一个可偏向而未偏向的对象（MarkWord的最后 3 位为 101，并且 Thread Id 字段的值为 0）。</p> <p><strong>偏向锁的加锁</strong></p> <ul><li>偏向锁标志是未偏向状态，使用 CAS 将 MarkWord 中的线程ID设置为自己的线程ID
<ul><li>如果成功，则获取偏向锁成功。</li> <li>如果失败，则进行锁升级。</li></ul></li> <li>偏向锁标志是已偏向状态
<ul><li>MarkWord 中的线程 ID 是自己的线程 ID，成功获取锁</li> <li>MarkWord 中的线程 ID 不是自己的线程 ID，需要进行锁升级</li></ul></li></ul> <p>偏向锁的锁升级需要进行偏向锁的撤销。</p> <p><strong>偏向锁的撤销</strong></p> <ul><li>对象是不可偏向状态
<ul><li>不需要撤销</li></ul></li> <li>对象是可偏向状态
<ul><li>MarkWord 中指向的线程不存活
<ul><li>允许重偏向：退回到可偏向但未偏向的状态</li> <li>不允许重偏向：变为无锁状态</li></ul></li> <li>MarkWord 中的线程存活、
<ul><li>线程ID指向的线程仍然拥有锁
<ul><li>升级为轻量级锁，将 mark word 复制到线程栈中</li></ul></li> <li>不再拥有锁
<ul><li>允许重偏向：退回到可偏向但未偏向的状态</li> <li>不允许重偏向：变为无锁状态</li></ul></li></ul></li></ul></li></ul> <p><strong>小结：</strong> 撤销偏向的操作需要在全局检查点执行。我们假设线程A曾经拥有锁（不确定是否释放锁）， 线程B来竞争锁对象，如果当线程A不在拥有锁时或者死亡时，线程B直接去尝试获得锁（根据是否 允许重偏向（<code>rebiasing</code>），获得偏向锁或者轻量级锁）；如果线程A仍然拥有锁，那么锁 升级为轻量级锁，线程B自旋请求获得锁。</p> <p><strong>2、轻量级锁</strong>是指仅仅使用 CAS 进行操作，实现获取锁。</p> <p><strong>加锁流程</strong></p> <p>首先，线程由偏向锁升级为轻量级锁时，会先把<strong>锁的对象头MarkWord复制一份到线程的栈帧中，建立一个名为锁记录空间（Lock Record），用于存储当前Mark Word的拷贝</strong>。</p> <p>其次，<strong>线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录</strong>（<code>Lock Record</code>）的指针，如果成功，当前线程获得轻量级锁，如果失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数 达到界限值（<code>threshold</code>），轻量级锁将会膨胀为重量级锁。</p> <p>如果线程发现对象头中Mark Word已经存在指向自己栈帧的指针，即线程已经获得轻量级锁，那么只需要将0存储在自己的栈帧中（此过程称为<strong>递归加锁</strong>）；在解锁的时候，如果发现锁记录的内容为0， 那么只需要移除栈帧中的锁记录即可，而不需要更新Mark Word。</p> <p><strong>撤销流程</strong></p> <p>轻量级锁解锁时，如果对象的Mark Word仍然指向着线程的锁记录，会使用CAS操作， 将Dispalced Mark Word替换到对象头，如果成功，则表示没有竞争发生。如果失败， 表示当前锁存在锁竞争，锁就会膨胀为重量级锁。</p> <p><strong>3、重量级锁</strong>（<code>heavy weight lock</code>），是使用操作系统互斥量（<code>mutex</code>）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。但是注意，当锁膨胀（<code>inflate</code>）为重量锁时，就不能再退回到轻量级锁。</p> <h2 id="aqs"><a href="#aqs" class="header-anchor">#</a> AQS</h2> <p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p> <blockquote><p>CLH(Craig, Landin and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote> <p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p> <p><strong>AQS 定义两种资源共享方式</strong></p> <ul><li><p>Exclusive</p> <p>（独占）：只有一个线程能执行，如<code>ReentrantLock</code>。又可分为公平锁和非公平锁：</p> <ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li> <li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li> <li><p><strong>Share</strong>（共享）：多个线程可同时执行，如<code>CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code></p> <ul><li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li> <li><strong><code>CountDownLatch</code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来<strong>协调多个线程之间的同步</strong>。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li> <li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li></ul></li></ul> <p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p> <p>不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可</strong>。</p> <p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p> <ul><li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（对于共享资源 state 的获取和释放）</li> <li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ul> <p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p> <p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p> <p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p> <p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p> <ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li> <li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li> <li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul> <blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而**<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例**，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote> <h2 id="volatile"><a href="#volatile" class="header-anchor">#</a> volatile</h2> <p><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</p> <p><strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong> CPU Cache 的工作方式：</p> <p>先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p> <p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。</strong></p> <p><strong>并发编程的重要特征：</strong></p> <ul><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li> <li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li> <li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ul> <p><strong><code>synchronized</code> 和 <code>volatile</code> 区别：</strong></p> <p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p> <ul><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li> <li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li> <li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul> <p><strong>ThreadLocal 内存泄漏问题</strong></p> <p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p> <h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <p><strong>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。使用线程池的好处：</strong></p> <ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li> <li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li> <li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul> <p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p> <ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li> <li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li> <li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul> <p><code>ThreadPoolExecutor</code>其他常见参数:</p> <ul><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li> <li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li> <li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li> <li><strong><code>handler</code></strong> ：饱和策略，指如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时。
<ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> **抛出 <code>RejectedExecutionException</code>**来拒绝新任务的处理。</li> <li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> <strong>调用执行自己的线程运行任</strong>务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li> <li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> <strong>不处理新任务，直接丢弃掉。</strong></li> <li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> <strong>此策略将丢弃最早的未处理的任务请求。</strong></li></ul></li></ul> <p>对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。</p></div></article> <section class="post-meta main-div" data-v-cae733bc><section class="post-date clearfix" data-v-cae733bc><span class="create-date" data-v-cae733bc>
        Created : 2022-01-15
      </span> <!----> <br data-v-cae733bc></section> <section class="post-links" data-v-cae733bc><a href="/posts/2022/01/15/computer-network.html" class="post-link" data-v-cae733bc>
        Previous Post : Computer Network
      </a> <a href="/posts/2022/01/15/os.html" class="post-link" data-v-cae733bc>
        Next Post : 操作系统基础杂谈
      </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-41e4f7f8><div class="info-card main-div" data-v-1732e38d data-v-41e4f7f8><div class="info-card-header" data-v-1732e38d><img src="/assets/img/Abyss.jpg" alt="Abyss Wang" class="info-avatar" data-v-1732e38d></div> <div class="info-card-body" data-v-1732e38d><section class="info-nickname" data-v-1732e38d>
      Abyss Wang
    </section> <section class="info-desc" data-v-1732e38d>Happy Coding<br/>Happy Life</section> <section class="info-contact" data-v-1732e38d><section data-v-1732e38d><span title="Hangzhou, China" data-v-1732e38d data-v-1732e38d><svg class="icon" style="font-size:1em;" data-v-1732e38d data-v-1732e38d><title data-v-1732e38d data-v-1732e38d>Hangzhou, China</title><use xlink:href="#icon-location" data-v-1732e38d data-v-1732e38d></use></svg><span class="info-text" data-v-1732e38d data-v-1732e38d>
          Hangzhou, China
        </span></span></section> <section data-v-1732e38d><span title="ZJUT/ZJU" data-v-1732e38d data-v-1732e38d><svg class="icon" style="font-size:1em;" data-v-1732e38d data-v-1732e38d><title data-v-1732e38d data-v-1732e38d>ZJUT/ZJU</title><use xlink:href="#icon-organization" data-v-1732e38d data-v-1732e38d></use></svg><span class="info-text" data-v-1732e38d data-v-1732e38d>
          ZJUT/ZJU
        </span></span></section> <section data-v-1732e38d><a href="mailto:wxuanye@yeah.net" title="wxuanye@yeah.net" data-v-1732e38d data-v-1732e38d><svg class="icon" style="font-size:1em;" data-v-1732e38d data-v-1732e38d><title data-v-1732e38d data-v-1732e38d>wxuanye@yeah.net</title><use xlink:href="#icon-email" data-v-1732e38d data-v-1732e38d></use></svg><span class="info-text" data-v-1732e38d data-v-1732e38d>
          wxuanye@yeah.net
        </span></a></section></section></div> <div class="info-card-footer" data-v-1732e38d><section class="info-sns clearfix" data-v-1732e38d><a href="https://github.com/wangxye" target="_blank" class="sns-link" data-v-1732e38d><span title="GitHub: wangxye" class="sns-icon" data-v-1732e38d data-v-1732e38d><svg class="icon" style="font-size:1.5em;" data-v-1732e38d data-v-1732e38d><title data-v-1732e38d data-v-1732e38d>GitHub: wangxye</title><use xlink:href="#icon-github" data-v-1732e38d data-v-1732e38d></use></svg></span></a><a href="https://www.zhihu.com/people/black-panther-34" target="_blank" class="sns-link" data-v-1732e38d><span title="知乎: Abyss" class="sns-icon" data-v-1732e38d data-v-1732e38d><svg class="icon" style="font-size:1.5em;" data-v-1732e38d data-v-1732e38d><title data-v-1732e38d data-v-1732e38d>知乎: Abyss</title><use xlink:href="#icon-zhihu" data-v-1732e38d data-v-1732e38d></use></svg></span></a><a href="https://www.csdn.net/" target="_blank" class="sns-link" data-v-1732e38d><span title="CSDN: " class="sns-icon" data-v-1732e38d data-v-1732e38d><svg class="icon" style="font-size:1.5em;" data-v-1732e38d data-v-1732e38d><title data-v-1732e38d data-v-1732e38d>CSDN: </title><use xlink:href="#icon-csdn" data-v-1732e38d data-v-1732e38d></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-41e4f7f8><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>Table of Contents</span> <div class="post-nav-toc"><ul><li><a href="/posts/2022/01/15/jvm.html#垃圾回收算法">垃圾回收算法</a></li><li><a href="/posts/2022/01/15/jvm.html#synchronized-锁优化">synchronized 锁优化</a></li><li><a href="/posts/2022/01/15/jvm.html#aqs">AQS</a></li><li><a href="/posts/2022/01/15/jvm.html#volatile">volatile</a></li><li><a href="/posts/2022/01/15/jvm.html#线程池">线程池</a></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/posts/2022/01/15/jvm.html#post-comments">
      Comments
    </a></div></div></aside></div> <footer class="footer" data-v-24c54b5c><p class="footer-sns-links" data-v-24c54b5c><a href="https://github.com/wangxye" target="_blank" class="sns-link" data-v-24c54b5c><span title="GitHub: wangxye" class="sns-icon" data-v-24c54b5c data-v-24c54b5c><svg class="icon" style="font-size:25px;" data-v-24c54b5c data-v-24c54b5c><title data-v-24c54b5c data-v-24c54b5c>GitHub: wangxye</title><use xlink:href="#icon-github" data-v-24c54b5c data-v-24c54b5c></use></svg></span></a><a href="https://www.zhihu.com/people/black-panther-34" target="_blank" class="sns-link" data-v-24c54b5c><span title="知乎: Abyss" class="sns-icon" data-v-24c54b5c data-v-24c54b5c><svg class="icon" style="font-size:25px;" data-v-24c54b5c data-v-24c54b5c><title data-v-24c54b5c data-v-24c54b5c>知乎: Abyss</title><use xlink:href="#icon-zhihu" data-v-24c54b5c data-v-24c54b5c></use></svg></span></a><a href="https://www.csdn.net/" target="_blank" class="sns-link" data-v-24c54b5c><span title="CSDN: " class="sns-icon" data-v-24c54b5c data-v-24c54b5c><svg class="icon" style="font-size:25px;" data-v-24c54b5c data-v-24c54b5c><title data-v-24c54b5c data-v-24c54b5c>CSDN: </title><use xlink:href="#icon-csdn" data-v-24c54b5c data-v-24c54b5c></use></svg></span></a></p> <div class="busuanzi" data-v-24c54b5c><span id="busuanzi_container_site_pv" style="display:none" data-v-24c54b5c>
    本站总访问量
    <span id="busuanzi_value_site_pv" data-v-24c54b5c></span>次
    <span class="post-meta-divider" data-v-24c54b5c>|</span></span> <span id="busuanzi_container_site_uv" style="display:none" data-v-24c54b5c>
    本站访客数
    <span id="busuanzi_value_site_uv" data-v-24c54b5c></span>人
  </span></div> <p class="footer-text" data-v-24c54b5c>Copyright 2021-present <a href="https://github.com/wangxye" target="_blank">wangxye</a> | MIT License</p></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/vendor.vue.8c2dfada.js" defer></script><script src="/assets/js/8.49c1931d.js" defer></script><script src="/assets/js/18.51cabdfa.js" defer></script><script src="/assets/js/vendor.commons.6d048c9e.js" defer></script><script src="/assets/js/app.33c1ef9e.js" defer></script>
  </body>
</html>
