(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{300:function(_,v,e){"use strict";e.r(v);var s=e(4),t=Object(s.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mysql原理-锁应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql原理-锁应用"}},[_._v("#")]),_._v(" Mysql原理——锁应用")]),_._v(" "),e("p",[_._v("事务的"),e("code",[_._v("隔离性")]),_._v("由"),e("code",[_._v("锁")]),_._v("来实现。")]),_._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[_._v("#")]),_._v(" 概述")]),_._v(" "),e("p",[_._v("在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对"),e("code",[_._v("并发操作进行控制")]),_._v("，因此产生了"),e("code",[_._v("锁")]),_._v("。同时"),e("code",[_._v("锁机制")]),_._v("也为实现MySQL的各个隔离级别提供了保证。"),e("code",[_._v("锁冲突")]),_._v("也是影响数据库"),e("code",[_._v("并发访问性能")]),_._v("的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。")]),_._v(" "),e("h2",{attrs:{id:"mysql并发事务访问相同记录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql并发事务访问相同记录"}},[_._v("#")]),_._v(" MySQL并发事务访问相同记录")]),_._v(" "),e("p",[_._v("并发事务访问相同记录的情况大致可以划分为 3 种：")]),_._v(" "),e("h3",{attrs:{id:"读-读情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#读-读情况"}},[_._v("#")]),_._v(" 读-读情况")]),_._v(" "),e("p",[e("code",[_._v("读-读")]),_._v("情况，即并发事务相继"),e("code",[_._v("读取相同的记录")]),_._v("。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。")]),_._v(" "),e("h3",{attrs:{id:"写-写情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写-写情况"}},[_._v("#")]),_._v(" 写-写情况")]),_._v(" "),e("p",[e("code",[_._v("写-写")]),_._v("情况，即并发事务相继对相同的记录做出改动。")]),_._v(" "),e("p",[_._v("在这种情况下会发生"),e("code",[_._v("脏写")]),_._v("的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们"),e("code",[_._v("排队执行")]),_._v("，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个"),e("code",[_._v("内存中的结构")]),_._v("，在事务执行前本来是没有锁的，也就是说一开始是没有"),e("code",[_._v("锁结构")]),_._v("和记录进行关联的，如图所示：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-1.png",alt:"mysql-1.jpg"}})]),_._v(" "),e("p",[_._v("当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的"),e("code",[_._v("锁结构")]),_._v("，当没有的时候就会在内存中生成一个"),e("code",[_._v("锁结构")]),_._v("与之关联。比如，事务"),e("code",[_._v("T1")]),_._v("要对这条记录做改动，就需要生成一个"),e("code",[_._v("锁结构")]),_._v("与之关联：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-2.png",alt:"mysql-2.jpg"}})]),_._v(" "),e("p",[_._v("小结几种说法：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("不加锁")]),_._v(" "),e("p",[_._v("意思就是不需要在内存中生成对应的"),e("code",[_._v("锁结构")]),_._v("，可以直接执行操作。")])]),_._v(" "),e("li",[e("p",[_._v("获取锁成功，或者加锁成功")]),_._v(" "),e("p",[_._v("意思就是在内存中生成了对应的"),e("code",[_._v("锁结构")]),_._v("，而且锁结构的"),e("code",[_._v("is_waiting")]),_._v("属性为"),e("code",[_._v("false")]),_._v("，也就是事务\n可以继续执行操作。")])]),_._v(" "),e("li",[e("p",[_._v("获取锁失败，或者加锁失败，或者没有获取到锁")]),_._v(" "),e("p",[_._v("意思就是在内存中生成了对应的"),e("code",[_._v("锁结构")]),_._v("，不过锁结构的"),e("code",[_._v("is_waiting")]),_._v("属性为"),e("code",[_._v("true")]),_._v("，也就是事务\n需要等待，不可以继续执行操作。")])])]),_._v(" "),e("h3",{attrs:{id:"读-写或写-读情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#读-写或写-读情况"}},[_._v("#")]),_._v(" 读-写或写-读情况")]),_._v(" "),e("p",[e("code",[_._v("读-写")]),_._v("或"),e("code",[_._v("写-读")]),_._v("，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生"),e("code",[_._v("脏读")]),_._v("、"),e("code",[_._v("不可重复读")]),_._v("、"),e("code",[_._v("幻读")]),_._v("的问题。")]),_._v(" "),e("p",[_._v("各个数据库厂商对"),e("code",[_._v("SQL标准")]),_._v("的支持都可能不一样。比如MySQL在"),e("code",[_._v("REPEATABLE READ")]),_._v("隔离级别上就已经解决了"),e("code",[_._v("幻读")]),_._v("问题。")]),_._v(" "),e("h3",{attrs:{id:"并发问题的解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发问题的解决方案"}},[_._v("#")]),_._v(" 并发问题的解决方案")]),_._v(" "),e("p",[_._v("怎么解决"),e("code",[_._v("脏读")]),_._v("、"),e("code",[_._v("不可重复读")]),_._v("、"),e("code",[_._v("幻读")]),_._v("这些问题呢？其实有两种可选的解决方案：")]),_._v(" "),e("ul",[e("li",[_._v("方案一：读操作利用多版本并发控制（"),e("code",[_._v("MVCC")]),_._v("，下章讲解），写操作进行"),e("code",[_._v("加锁")]),_._v("。")])]),_._v(" "),e("blockquote",[e("p",[_._v("普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。")]),_._v(" "),e("ul",[e("li",[_._v("在"),e("code",[_._v("READ COMMITTED")]),_._v("隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了"),e("code",[_._v("事务不可以读取到未提交的事务所做的更改")]),_._v("，也是避免了脏读现象；")]),_._v(" "),e("li",[_._v("在"),e("code",[_._v("REPEATABLE READ")]),_._v("隔离级别下，一个事务在执行过程中只有"),e("code",[_._v("第一次执行SELECT操作")]),_._v("才会生成一个ReadView，之后的SELECT操作都"),e("code",[_._v("复用")]),_._v("这个ReadView，这样也就避免了不可重复读和幻读的问题。")])])]),_._v(" "),e("ul",[e("li",[e("p",[_._v("方案二：读、写操作都采用加锁的方式。")])]),_._v(" "),e("li",[e("p",[_._v("小结对比发现：")]),_._v(" "),e("ul",[e("li",[_._v("采用"),e("code",[_._v("MVCC")]),_._v("方式的话，"),e("code",[_._v("读-写")]),_._v("操作彼此并不冲突，"),e("code",[_._v("性能更高")]),_._v("。")]),_._v(" "),e("li",[_._v("采用"),e("code",[_._v("加锁")]),_._v("方式的话，"),e("code",[_._v("读-写")]),_._v("操作彼此需要"),e("code",[_._v("排队执行")]),_._v("，影响性能。")])]),_._v(" "),e("p",[_._v("一般情况下我们当然愿意采用"),e("code",[_._v("MVCC")]),_._v("来解决"),e("code",[_._v("读-写")]),_._v("操作并发执行的问题，但是业务在某些特殊情下，要求必须采用"),e("code",[_._v("加锁")]),_._v("的方式执行。下面就讲解下MySQL中不同类别的锁。")])])]),_._v(" "),e("h2",{attrs:{id:"锁的不同角度分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁的不同角度分类"}},[_._v("#")]),_._v(" 锁的不同角度分类")]),_._v(" "),e("p",[_._v("锁的分类图，如下：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-3.png",alt:"mysql-3.jpg"}})]),_._v(" "),e("h3",{attrs:{id:"操作类型划分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作类型划分"}},[_._v("#")]),_._v(" 操作类型划分")]),_._v(" "),e("p",[_._v("从数据操作的类型划分：读锁、写锁")]),_._v(" "),e("ul",[e("li",[e("p",[e("code",[_._v("读锁")]),_._v("：也称为"),e("code",[_._v("共享锁")]),_._v("、英文用"),e("code",[_._v("S")]),_._v("表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("写锁")]),_._v("：也称为"),e("code",[_._v("排他锁")]),_._v("、英文用"),e("code",[_._v("X")]),_._v("表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。")])])]),_._v(" "),e("p",[e("strong",[_._v("需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。")])]),_._v(" "),e("h3",{attrs:{id:"操作的粒度划分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作的粒度划分"}},[_._v("#")]),_._v(" 操作的粒度划分")]),_._v(" "),e("p",[_._v("从数据操作的粒度划分：表级锁、页级锁、行锁")]),_._v(" "),e("h4",{attrs:{id:"表锁-table-lock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#表锁-table-lock"}},[_._v("#")]),_._v(" 表锁（Table Lock）")]),_._v(" "),e("p",[_._v("① 表级别的S锁、X锁")]),_._v(" "),e("p",[_._v("在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的"),e("code",[_._v("S锁")]),_._v("或者"),e("code",[_._v("X锁")]),_._v("的。在对某个表执行一些诸如"),e("code",[_._v("ALTER TABLE")]),_._v("、"),e("code",[_._v("DROP TABLE")]),_._v("这类的"),e("code",[_._v("DDL")]),_._v("语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行"),e("code",[_._v("DDL")]),_._v("语句也会发生阻塞。这个过程其实是通过在"),e("code",[_._v("server")]),_._v("层使用一种称之为"),e("code",[_._v("元数据锁")]),_._v("（英文名："),e("code",[_._v("Metadata Locks")]),_._v("，简称"),e("code",[_._v("MDL")]),_._v("）结构来实现的。")]),_._v(" "),e("p",[_._v("一般情况下，不会使用InnoDB存储引擎提供的表级别的"),e("code",[_._v("S锁")]),_._v("和"),e("code",[_._v("X锁")]),_._v("。只会在一些特殊情况下，比方说"),e("code",[_._v("崩溃恢复")]),_._v("过程中用到。比如，在系统变量"),e("code",[_._v("autocommit=0，innodb_table_locks = 1")]),_._v("时，手动获取InnoDB存储引擎提供的表t的"),e("code",[_._v("S锁")]),_._v("或者"),e("code",[_._v("X锁")]),_._v("可以这么写：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("LOCK TABLES t READ")]),_._v("：InnoDB存储引擎会对表"),e("code",[_._v("t")]),_._v("加表级别的"),e("code",[_._v("S锁")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("LOCK TABLES t WRITE")]),_._v("：InnoDB存储引擎会对表"),e("code",[_._v("t")]),_._v("加表级别的"),e("code",[_._v("X锁")]),_._v("。")])]),_._v(" "),e("p",[_._v("不过尽量避免在使用InnoDB存储引擎的表上使用"),e("code",[_._v("LOCK TABLES")]),_._v("这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的"),e("code",[_._v("行锁")]),_._v("，关于InnoDB表级别的"),e("code",[_._v("S锁")]),_._v("和"),e("code",[_._v("X锁")]),_._v("大家了解一下就可以了。")]),_._v(" "),e("p",[_._v("MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）")]),_._v(" "),e("ul",[e("li",[_._v("表共享读锁（Table Read Lock）")]),_._v(" "),e("li",[_._v("表独占写锁（Table Write Lock）")])]),_._v(" "),e("table",[e("thead",[e("tr",[e("th",[_._v("锁类型")]),_._v(" "),e("th",[_._v("自己可读")]),_._v(" "),e("th",[_._v("自己可写")]),_._v(" "),e("th",[_._v("自己可操作其他表")]),_._v(" "),e("th",[_._v("他人可读")]),_._v(" "),e("th",[_._v("他人可写")])])]),_._v(" "),e("tbody",[e("tr",[e("td",[_._v("读锁")]),_._v(" "),e("td",[_._v("是")]),_._v(" "),e("td",[_._v("否")]),_._v(" "),e("td",[_._v("否")]),_._v(" "),e("td",[_._v("是")]),_._v(" "),e("td",[_._v("否，等")])]),_._v(" "),e("tr",[e("td",[_._v("写锁")]),_._v(" "),e("td",[_._v("是")]),_._v(" "),e("td",[_._v("是")]),_._v(" "),e("td",[_._v("否")]),_._v(" "),e("td",[_._v("否，等")]),_._v(" "),e("td",[_._v("否，等")])])])]),_._v(" "),e("p",[_._v("② 意向锁 （intention lock）")]),_._v(" "),e("p",[_._v("InnoDB 支持"),e("code",[_._v("多粒度锁（multiple granularity locking）")]),_._v("，它允许"),e("code",[_._v("行级锁")]),_._v("与"),e("code",[_._v("表级锁")]),_._v("共存，而 意向锁 就是其中的一种"),e("code",[_._v("表锁")]),_._v("。")]),_._v(" "),e("p",[_._v("意向锁分为两种：")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("意向共享锁")]),_._v(" （intention shared lock, IS）：事务有意向对表中的某些行加 "),e("strong",[_._v("共享锁")]),_._v(" （S锁）")])]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("column")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("table")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("LOCK")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("IN")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SHARE")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("MODE")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br")])]),e("ul",[e("li",[e("strong",[_._v("意向排他锁")]),_._v(" （intention exclusive lock, IX）：事务有意向对表中的某些行加 "),e("strong",[_._v("排他锁")]),_._v(" （X锁）")])]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("column")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("table")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FOR")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("UPDATE")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br")])]),e("p",[_._v("即：意向锁是由存储引擎"),e("strong",[_._v("自己维护")]),_._v("的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行"),e("strong",[_._v("所在数据表的对应意向锁")]),_._v("。")]),_._v(" "),e("p",[e("strong",[_._v("意向锁的并发性")])]),_._v(" "),e("p",[_._v("意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）")]),_._v(" "),e("p",[_._v("我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）。")]),_._v(" "),e("p",[e("strong",[_._v("从上面的案例可以得到如下结论：")])]),_._v(" "),e("ol",[e("li",[_._v("InnoDB 支持"),e("strong",[_._v("多粒度锁")]),_._v("，特定场景下，行级锁可以与表级锁共存。")]),_._v(" "),e("li",[_._v("意向锁之间互不排斥，但除了 IS 与 S 兼容外，"),e("strong",[_._v("意向锁会与 共享锁 / 排他锁 互斥")]),_._v("。")]),_._v(" "),e("li",[_._v("IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。")]),_._v(" "),e("li",[_._v("意向锁在保证并发性的前提下，实现了"),e("strong",[_._v("行锁和表锁共存")]),_._v("且"),e("strong",[_._v("满足事务隔离性")]),_._v("的要求。")])]),_._v(" "),e("p",[_._v("③ 自增锁（AUTO-INC锁）")]),_._v(" "),e("p",[_._v("在使用MySQL过程中，我们可以为表的某个列添加AUTO_INCREMENT属性。举例：")]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("CREATE")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("TABLE")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token identifier"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")]),_._v("teacher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")])]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token identifier"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")]),_._v("id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")])]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("NOT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[_._v("NULL")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("AUTO_INCREMENT")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token identifier"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")]),_._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")])]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("varchar")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("255")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("NOT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[_._v("NULL")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("PRIMARY")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("KEY")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),e("span",{pre:!0,attrs:{class:"token identifier"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")]),_._v("id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("ENGINE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("InnoDB")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("DEFAULT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("CHARSET")]),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v("utf8mb4 "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("COLLATE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v("utf8mb4_0900_ai_ci"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br")])]),e("p",[_._v("由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改如下所示。")]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("INSERT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("INTO")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token identifier"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")]),_._v("teacher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")])]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("VALUES")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[_._v("'zhangsan'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[_._v("'lisi'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br")])]),e("p",[_._v("上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。")]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[_._v("mysql"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v(">")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("select")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("from")]),_._v(" teacher"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("+")]),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("----+----------+")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" id "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" name "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("+")]),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("----+----------+")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" zhangsan "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("2")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" lisi "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("+")]),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("----+----------+")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("2")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("rows")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("in")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("set")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("0.00")]),_._v(" sec"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br"),e("span",{staticClass:"line-number"},[_._v("6")]),e("br"),e("span",{staticClass:"line-number"},[_._v("7")]),e("br"),e("span",{staticClass:"line-number"},[_._v("8")]),e("br")])]),e("p",[_._v("现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是“Simple inserts”，“Bulk inserts”和“Mixed-mode inserts”。")]),_._v(" "),e("p",[e("strong",[_._v("1. “Simple inserts” （简单插入）")])]),_._v(" "),e("p",[_._v("可以"),e("code",[_._v("预先确定要插入的行数")]),_._v("（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行\n"),e("code",[_._v("INSERT...VALUES()")]),_._v("和"),e("code",[_._v("REPLACE")]),_._v("语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行\n数。")]),_._v(" "),e("p",[e("strong",[_._v("2. “Bulk inserts” （批量插入）")])]),_._v(" "),e("p",[e("code",[_._v("事先不知道要插入的行数")]),_._v("（和所需自动递增值的数量）的语句。比如"),e("code",[_._v("INSERT ... SELECT")]),_._v("，"),e("code",[_._v("REPLACE... SELECT")]),_._v("和"),e("code",[_._v("LOAD DATA")]),_._v("语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。")]),_._v(" "),e("p",[e("strong",[_._v("3. “Mixed-mode inserts” （混合模式插入）")])]),_._v(" "),e("p",[_._v("这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如"),e("code",[_._v("INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');")]),_._v("只是指定了部分id的值。另一种类型的“混合模式插入”是 "),e("code",[_._v("INSERT ... ON DUPLICATE KEY UPDATE。")])]),_._v(" "),e("p",[_._v("innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：")]),_._v(" "),e("p",[e("code",[_._v("（1）innodb_autoinc_lock_mode = 0(“传统”锁定模式)")])]),_._v(" "),e("p",[_._v("在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有\nAUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会"),e("code",[_._v("限制并发")]),_._v("能力。")]),_._v(" "),e("p",[e("code",[_._v("（2）innodb_autoinc_lock_mode = 1(“连续”锁定模式)")])]),_._v(" "),e("p",[_._v("在 MySQL 8.0 之前，连续锁定模式是"),e("code",[_._v("默认")]),_._v("的。")]),_._v(" "),e("p",[_._v("在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT ...SELECT，REPLACE ... SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。")]),_._v(" "),e("p",[_._v("对于“Simple inserts”（要插入的行数事先已知），则通过在"),e("code",[_._v("mutex（轻量锁）")]),_._v("的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。")]),_._v(" "),e("p",[e("code",[_._v("（3）innodb_autoinc_lock_mode = 2(“交错”锁定模式)")])]),_._v(" "),e("p",[_._v("从 MySQL 8.0 开始，交错锁模式是"),e("code",[_._v("默认")]),_._v("设置。")]),_._v(" "),e("p",[_._v("在此锁定模式下，自动递增值"),e("code",[_._v("保证")]),_._v("在所有并发执行的所有类型的insert语句中是"),e("code",[_._v("唯一")]),_._v("且"),e("code",[_._v("单调递增")]),_._v("的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号）， "),e("strong",[_._v("为任何给定语句插入的行生成的值可不是连续的")]),_._v("。")]),_._v(" "),e("p",[_._v("④ 元数据锁（MDL锁）")]),_._v(" "),e("p",[_._v("MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个"),e("code",[_._v("表结构做变更")]),_._v("，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。")]),_._v(" "),e("p",[_._v("因此， "),e("strong",[_._v("当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。")])]),_._v(" "),e("h4",{attrs:{id:"行锁-row-lock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行锁-row-lock"}},[_._v("#")]),_._v(" 行锁（Row Lock）")]),_._v(" "),e("p",[_._v("① 记录锁（Record Locks）")]),_._v(" "),e("p",[_._v("记录锁也就是仅仅把一条记录锁上，官方的类型名称为： LOCK_REC_NOT_GAP 。")]),_._v(" "),e("p",[_._v("比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-4.png",alt:"mysql-4"}})]),_._v(" "),e("p",[_._v("举例如下：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-5.png",alt:"mysql-5"}})]),_._v(" "),e("p",[_._v("记录锁是有S锁和X锁之分的，称之为 "),e("code",[_._v("S型记录锁")]),_._v(" 和 "),e("code",[_._v("X型记录锁")]),_._v(" 。")]),_._v(" "),e("ul",[e("li",[_._v("当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可 以继续获取X型记录锁；")]),_._v(" "),e("li",[_._v("当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不 可以继续获取X型记录锁。")])]),_._v(" "),e("p",[_._v("② 间隙锁（Gap Locks）")]),_._v(" "),e("p",[e("code",[_._v("MySQL")]),_._v(" 在 "),e("code",[_._v("REPEATABLE READ")]),_._v(" 隔离级别下是可以解决幻读问题的，解决方案有两种：")]),_._v(" "),e("ul",[e("li",[_._v("可以使用 "),e("code",[_._v("MVCC")]),_._v(" 方案解决；")]),_._v(" "),e("li",[_._v("可以采用 "),e("code",[_._v("加锁")]),_._v(" 方案解决；")])]),_._v(" "),e("p",[_._v("但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些"),e("code",[_._v("幻影记录")]),_._v("加上"),e("code",[_._v("记录锁")]),_._v(" 。")]),_._v(" "),e("p",[e("code",[_._v("InnoDB")]),_._v("提出了一种称之为 "),e("code",[_._v("Gap Locks")]),_._v(" 的锁，官方的类型名称为： "),e("code",[_._v("LOCK_GAP")]),_._v(" ，我们可以简称为 "),e("code",[_._v("gap锁")]),_._v(" 。")]),_._v(" "),e("p",[_._v("比如，把id值为8的那条记录加一个gap锁的示意图如下。")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-6.png",alt:"mysql-6"}})]),_._v(" "),e("p",[_._v("图中id值为8的记录加了gap锁，意味着 "),e("code",[_._v("不允许别的事务在id值为8的记录前边的间隙插入新记录")]),_._v(" ，其实就是 id列的值"),e("code",[_._v("(3, 8)")]),_._v("这个区间的新记录是不允许立即插入的。")]),_._v(" "),e("p",[_._v("比如，有另外一个事务再想插入一条id值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。")]),_._v(" "),e("p",[e("strong",[_._v("gap锁的提出仅仅是为了防止插入幻影记录而提出的。")])]),_._v(" "),e("p",[_._v("③ 临键锁（Next-Key Locks）")]),_._v(" "),e("p",[_._v("有时候我们既想"),e("code",[_._v("锁住某条记录")]),_._v("，又想 "),e("code",[_._v("阻止")]),_._v(" 其他事务在该记录前边的 "),e("code",[_._v("间隙插入新记录")]),_._v(" ，所以"),e("code",[_._v("InnoDB")]),_._v("就提 出了一种称之为 "),e("code",[_._v("Next-Key Locks")]),_._v(" 的锁，官方的类型名称为： "),e("code",[_._v("LOCK_ORDINARY")]),_._v(" ，我们也可以简称为 "),e("code",[_._v("next-key")]),_._v("锁 。")]),_._v(" "),e("p",[e("code",[_._v("Next-Key Locks")]),_._v("是在存储引擎 "),e("code",[_._v("innodb")]),_._v(" 、事务级别在 "),e("code",[_._v("可重复读")]),_._v(" 的情况下使用的数据库锁， "),e("code",[_._v("innodb")]),_._v("默认的锁就是"),e("code",[_._v("Next-Key locks")]),_._v("。")]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("begin")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("select")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("from")]),_._v(" student "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("where")]),_._v(" id "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("<=")]),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("8")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("and")]),_._v(" id "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v(">")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[_._v("3")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("for")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("update")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br")])]),e("p",[_._v("④ 插入意向锁（Insert Intention Locks）")]),_._v(" "),e("p",[_._v("我们说一个事务在 "),e("code",[_._v("插入")]),_._v(" 一条记录时需要判断一下插入位置是不是被别的事务加了 "),e("code",[_._v("gap锁")]),_._v(" （ "),e("code",[_._v("next-key")]),_._v("锁 也包含 "),e("code",[_._v("gap锁")]),_._v(" ），如果有的话，插入操作需要等待，直到拥有 "),e("code",[_._v("gap锁")]),_._v(" 的那个事务提交。")]),_._v(" "),e("p",[_._v("但是"),e("strong",[_._v("InnoDB规 定事务在等待的时候也需要在内存中生成一个锁结构")]),_._v("，表明有事务想在某个 间隙 中 插入 新记录，但是现在在等待。")]),_._v(" "),e("p",[e("code",[_._v("InnoDB")]),_._v("就把这种类型的锁命名为 "),e("code",[_._v("Insert Intention Locks")]),_._v(" ，官方的类型名称为： "),e("code",[_._v("LOCK_INSERT_INTENTION")]),_._v(" ，我们称为 "),e("code",[_._v("插入意向锁")]),_._v(" 。插入意向锁是一种 "),e("code",[_._v("Gap锁")]),_._v(" ，不是意向锁，在insert 操作时产生。")]),_._v(" "),e("p",[_._v("插入意向锁是在插入一条记录行前，"),e("code",[_._v("由 INSERT 操作产生的一种间隙锁")]),_._v(" 。")]),_._v(" "),e("p",[_._v("事实上"),e("strong",[_._v("插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁")]),_._v("。")]),_._v(" "),e("h4",{attrs:{id:"页锁-page-lock"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页锁-page-lock"}},[_._v("#")]),_._v(" 页锁（Page Lock）")]),_._v(" "),e("p",[_._v("页锁就是在 "),e("code",[_._v("页的粒度")]),_._v(" 上进行锁定，锁定的数据资源比行锁要多，因为"),e("strong",[_._v("一个页中可以有多个行记录")]),_._v("。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。"),e("strong",[_._v("页锁的开销 介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。")])]),_._v(" "),e("p",[_._v("每个层级的锁数量是有限制的，因为锁会占用内存空间， "),e("code",[_._v("锁空间的大小是有限的")]),_._v(" 。当某个层级的锁数量 "),e("code",[_._v("超过了这个层级的阈值")]),_._v("时，就会进行 "),e("code",[_._v("锁升级")]),_._v(" 。")]),_._v(" "),e("p",[_._v("锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的"),e("code",[_._v("锁空间降低")]),_._v("了，但同时数据的"),e("code",[_._v("并发度也下降")]),_._v("了。")]),_._v(" "),e("h3",{attrs:{id:"对待锁的态度划分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对待锁的态度划分"}},[_._v("#")]),_._v(" 对待锁的态度划分")]),_._v(" "),e("p",[_._v("从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待 "),e("code",[_._v("数据并发的思维方式")]),_._v(" 。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的 "),e("code",[_._v("设计思想")]),_._v(" 。")]),_._v(" "),e("h4",{attrs:{id:"悲观锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁"}},[_._v("#")]),_._v(" 悲观锁")]),_._v(" "),e("p",[_._v("悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。")]),_._v(" "),e("p",[_._v("悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上 锁，这样别人想拿这个数据就会 "),e("code",[_._v("阻塞")]),_._v(" 直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程）。")]),_._v(" "),e("p",[_._v("比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当 其他线程想要访问数据时，都需要阻塞挂起。Java中 "),e("code",[_._v("synchronized")]),_._v(" 和 "),e("code",[_._v("ReentrantLock")]),_._v(" 等独占锁就是"),e("code",[_._v("悲观锁")]),_._v("思想的实现。")]),_._v(" "),e("h4",{attrs:{id:"乐观锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[_._v("#")]),_._v(" 乐观锁")]),_._v(" "),e("p",[_._v("乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新 的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。")]),_._v(" "),e("p",[_._v("在程序上，我们可以采用 "),e("code",[_._v("版本号机制")]),_._v(" 或者 "),e("code",[_._v("CAS机制")]),_._v(" 实现。乐观锁适用于多读的应用类型， 这样可以提高吞吐量。在Java中 "),e("code",[_._v("java.util.concurrent.atomic")]),_._v(" 包下的原子变量类就是使用了乐观锁的一种实现方式："),e("code",[_._v("CAS")]),_._v("实现的。")]),_._v(" "),e("ul",[e("li",[_._v("乐观锁的版本号机制")])]),_._v(" "),e("p",[_._v("在表中设计一个 "),e("code",[_._v("版本字段 version")]),_._v(" ，第一次读的时候，会获取 version 字段的取值。然后对数据进行"),e("code",[_._v("更新或删除")]),_._v("操作时，会执行 "),e("code",[_._v("UPDATE ... SET version=version+1 WHERE version=version")]),_._v(" 。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。")]),_._v(" "),e("ul",[e("li",[_._v("乐观锁的时间戳机制")])]),_._v(" "),e("p",[_._v("时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。 你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或 者时间戳），从而证明当前拿到的数据是否最新。")]),_._v(" "),e("h4",{attrs:{id:"两种锁的适用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两种锁的适用场景"}},[_._v("#")]),_._v(" 两种锁的适用场景")]),_._v(" "),e("p",[_._v("从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("乐观锁")]),_._v(" 适合 "),e("code",[_._v("读操作多")]),_._v(" 的场景，相对来说写的操作比较少。它的优点在于 "),e("code",[_._v("程序实现 ， 不存在死锁")]),_._v(" 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。")]),_._v(" "),e("li",[e("code",[_._v("悲观锁")]),_._v(" 适合 "),e("code",[_._v("写操作多")]),_._v(" 的场景，因为写的操作具有 "),e("code",[_._v("排它性")]),_._v(" 。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止 "),e("code",[_._v("读 - 写")]),_._v(" 和 "),e("code",[_._v("写 - 写")]),_._v(" 的冲突。")])]),_._v(" "),e("h2",{attrs:{id:"锁的内存结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁的内存结构"}},[_._v("#")]),_._v(" 锁的内存结构")]),_._v(" "),e("p",[e("code",[_._v("InnoDB")]),_._v(" 存储引擎中的 锁结构 如下：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-7.png",alt:"mysql-7"}})]),_._v(" "),e("p",[_._v("结构解析：")]),_._v(" "),e("ol",[e("li",[_._v("锁所在的事务信息 ：")])]),_._v(" "),e("p",[_._v("不论是 "),e("code",[_._v("表锁")]),_._v(" 还是 "),e("code",[_._v("行锁")]),_._v(" ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个 事务的信息。")]),_._v(" "),e("p",[_._v("此 "),e("code",[_._v("锁所在的事务信息")]),_._v(" 在内存结构中只是一个"),e("code",[_._v("指针")]),_._v("，通过指针可以找到内存中关于该事务的更多信息，比方说"),e("code",[_._v("事务id")]),_._v("等。")]),_._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[_._v("索引信息 ：")])]),_._v(" "),e("p",[_._v("对于 "),e("code",[_._v("行锁")]),_._v(" 来说，需要记录一下加锁的记录是属于哪个索引的。")]),_._v(" "),e("p",[_._v("这里也是一个指针。")]),_._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[_._v("表锁／行锁信息 ：")])]),_._v(" "),e("p",[e("code",[_._v("表锁结构")]),_._v(" 和 "),e("code",[_._v("行锁结构")]),_._v(" 在这个位置的内容是不同的：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("表锁： 记载着是对哪个表加的锁，还有其他的一些信息。")])]),_._v(" "),e("li",[e("p",[_._v("行锁： 记载了三个重要的信息：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("Space ID ：记录所在表空间。")])]),_._v(" "),e("li",[e("p",[_._v("Page Number ：记录所在页号。")])]),_._v(" "),e("li",[e("p",[_._v("n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 n_bits 属性代表使用了多少比特位。")]),_._v(" "),e("blockquote",[e("p",[_._v("n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构")])])])])])]),_._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[_._v("type_mode ：")])]),_._v(" "),e("p",[_._v("这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-8.png",alt:"mysql-8"}})]),_._v(" "),e("ul",[e("li",[e("p",[_._v("锁的模式（ "),e("code",[_._v("lock_mode")]),_._v(" ），占用低4位，可选的值如下：")]),_._v(" "),e("ul",[e("li",[e("p",[e("code",[_._v("LOCK_IS")]),_._v(" （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("LOCK_IX")]),_._v(" （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("LOCK_S")]),_._v(" （十进制的 2 ）：表示共享锁，也就是 S锁 。")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("LOCK_X")]),_._v(" （十进制的 3 ）：表示独占锁，也就是 X锁 。")])]),_._v(" "),e("li",[e("p",[e("code",[_._v("LOCK_AUTO_INC")]),_._v(" （十进制的 4 ）：表示 AUTO-INC锁 。")]),_._v(" "),e("p",[_._v("在"),e("code",[_._v("InnoDB")]),_._v("存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。")])])])]),_._v(" "),e("li",[e("p",[_._v("锁的类型（ "),e("code",[_._v("lock_type")]),_._v(" ），占用第5～8位，不过现阶段只有第5位和第6位被使用：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("LOCK_TABLE")]),_._v(" （十进制的 "),e("code",[_._v("16")]),_._v(" ），也就是当第5个比特位置为1时，表示表级锁。")]),_._v(" "),e("li",[e("code",[_._v("LOCK_REC")]),_._v(" （十进制的 "),e("code",[_._v("32")]),_._v(" ），也就是当第6个比特位置为1时，表示行级锁。")])])]),_._v(" "),e("li",[e("p",[_._v("行锁的具体类型（ "),e("code",[_._v("rec_lock_type")]),_._v(" ），使用其余的位来表示。只有在 lock_type 的值为 LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("LOCK_ORDINARY")]),_._v(" （十进制的 0 ）：表示 "),e("code",[_._v("next-key锁")]),_._v(" 。")]),_._v(" "),e("li",[e("code",[_._v("LOCK_GAP")]),_._v(" （十进制的 512 ）：也就是当第10个比特位置为1时，表示 "),e("code",[_._v("gap锁")]),_._v(" 。")]),_._v(" "),e("li",[e("code",[_._v("LOCK_REC_NOT_GAP")]),_._v(" （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 "),e("code",[_._v("记录")]),_._v(" 锁 。")]),_._v(" "),e("li",[e("code",[_._v("LOCK_INSERT_INTENTION")]),_._v(" （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入 意向锁。其他的类型：还有一些不常用的类型我们就不多说了")])])]),_._v(" "),e("li",[e("p",[_._v("is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32 位的数字中：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("LOCK_WAIT")]),_._v(" （十进制的 256 ） ：当第9个比特位置为 "),e("code",[_._v("1")]),_._v(" 时，表示 "),e("code",[_._v("is_waiting")]),_._v(" 为 "),e("code",[_._v("true")]),_._v(" ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 "),e("code",[_._v("0")]),_._v(" 时，表示 "),e("code",[_._v("is_waiting")]),_._v(" 为 "),e("code",[_._v("false")]),_._v(" ，也就是当前事务获取锁成功。")])])])]),_._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[_._v("其他信息 ：")])]),_._v(" "),e("p",[_._v("为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。")]),_._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[_._v("一堆比特位 ：")])]),_._v(" "),e("p",[_._v("如果是 "),e("code",[_._v("行锁结构")]),_._v(" 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 "),e("code",[_._v("n_bits")]),_._v(" 属性 表示的。")]),_._v(" "),e("p",[e("code",[_._v("InnoDB")]),_._v("数据页中的每条记录在 "),e("code",[_._v("记录头信息")]),_._v(" 中都包含一个 "),e("code",[_._v("heap_no")]),_._v(" 属性，伪记录 "),e("code",[_._v("Infimum")]),_._v(" 的 "),e("code",[_._v("heap_no")]),_._v(" 值为 "),e("code",[_._v("0")]),_._v(" ， "),e("code",[_._v("Supremum")]),_._v(" 的 "),e("code",[_._v("heap_no")]),_._v(" 值为 "),e("code",[_._v("1")]),_._v(" ，之后每插入一条记录， heap_no 值就增1。 "),e("code",[_._v("锁结构")]),_._v(" 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 "),e("code",[_._v("heap_no")]),_._v(" ，即一个比特位映射到页内的一条记录。")]),_._v(" "),e("h2",{attrs:{id:"间隙锁加锁规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁加锁规则"}},[_._v("#")]),_._v(" 间隙锁加锁规则")]),_._v(" "),e("p",[_._v("间隙锁是在"),e("code",[_._v("可重复读隔离级别")]),_._v("下才会生效的： "),e("code",[_._v("next-key lock")]),_._v(" 实际上是由"),e("code",[_._v("间隙锁加行锁")]),_._v("实现的，如果切换 到"),e("code",[_._v("读提交隔离级别 (read-committed)")]),_._v(" 的话，就好理解了，过程中"),e("code",[_._v("去掉间隙锁")]),_._v("的部分，也就是"),e("code",[_._v("只剩下行锁")]),_._v(" 的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把 "),e("code",[_._v("binlog")]),_._v(" 格式设置为 "),e("code",[_._v("row")]),_._v(" 。也就是说，许多公司的配置为：读提交隔离级别加 "),e("code",[_._v("binlog_format=row")]),_._v("。业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。")]),_._v(" "),e("p",[_._v("next-key lock的加锁规则")]),_._v(" "),e("p",[_._v("总结的加锁规则里面，包含了两个 “ “ 原则 ” ” 、两个 “ “ 优化 ” ” 和一个 “bug” 。")]),_._v(" "),e("ol",[e("li",[_._v("原则 1 ：加锁的基本单位是 "),e("code",[_._v("next-key lock")]),_._v(" 。 next-key lock 是"),e("code",[_._v("前开后闭")]),_._v("区间。")]),_._v(" "),e("li",[_._v("原则 2 ：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终 都要"),e("code",[_._v("回溯到主键")]),_._v("上，在主键上也要加一把锁。")]),_._v(" "),e("li",[_._v("优化 1 ：索引上的"),e("code",[_._v("等值查询")]),_._v("，给"),e("code",[_._v("唯一索引")]),_._v("加锁的时候， next-key lock 退化为"),e("code",[_._v("行锁")]),_._v("。也就是说如果 "),e("code",[_._v("InnoDB")]),_._v("扫描的是一个"),e("code",[_._v("主键")]),_._v("、或是一个"),e("code",[_._v("唯一索引")]),_._v("的话，那"),e("code",[_._v("InnoDB")]),_._v("只会采用"),e("code",[_._v("行锁")]),_._v("方式来加锁")]),_._v(" "),e("li",[_._v("优化 2 ：索引上（"),e("code",[_._v("不一定是唯一索引")]),_._v("）的等值查询，"),e("code",[_._v("向右遍历时且最后一个值不满足等值条件的 时候")]),_._v("， next-keylock 退化为"),e("code",[_._v("间隙锁")]),_._v("。")]),_._v(" "),e("li",[_._v("一个 bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止。")])]),_._v(" "),e("p",[e("strong",[_._v("总结：")])]),_._v(" "),e("ol",[e("li",[_._v("加锁的基本单位为next-key lock = 间隙锁+行锁，范围为前开后闭，但加锁过程为先申请间隙锁在申请行锁。")]),_._v(" "),e("li",[_._v("只有访问到的对象才可以加锁。")]),_._v(" "),e("li",[_._v("等值查询：① 主键 / 唯一索引：命中--》next-key lock会退化为行锁，未命中--》退化为GAP Lock；② 非主键/ 普通索引：命中--》左右两边的GAP Lock + Record Lock；未命中--》退化为GAP Lock")]),_._v(" "),e("li",[_._v("等值查询：未命中："),e("code",[_._v("InnoDB")]),_._v("会向右继续遍历，找到第一个不符合的数据行，加next-key lock并退化为间隙锁。")]),_._v(" "),e("li",[_._v("范围查询：先找到符合条件的一行数据，再向右查找，向右查找时加的锁不会退化为间隙锁。")]),_._v(" "),e("li",[_._v("无论什么情况下，"),e("code",[_._v("InnoDB")]),_._v(" 会往前扫描到第一个不满足条件的行为止。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);