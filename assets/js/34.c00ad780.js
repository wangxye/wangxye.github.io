(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{315:function(_,v,e){"use strict";e.r(v);var t=e(4),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"mysql原理-多版本并发控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql原理-多版本并发控制"}},[_._v("#")]),_._v(" Mysql原理——多版本并发控制")]),_._v(" "),e("h2",{attrs:{id:"mvcc-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvcc-是什么"}},[_._v("#")]),_._v(" MVCC 是什么")]),_._v(" "),e("p",[_._v("MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的 "),e("code",[_._v("并发控制")]),_._v(" 。这项技术使得在"),e("code",[_._v("InnoDB")]),_._v("的事务隔离级别下执行 "),e("code",[_._v("一致性读")]),_._v(" 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。")]),_._v(" "),e("h2",{attrs:{id:"快照读与当前读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快照读与当前读"}},[_._v("#")]),_._v(" 快照读与当前读")]),_._v(" "),e("p",[_._v("MVCC在MySQL "),e("code",[_._v("InnoDB")]),_._v("中的实现主要是为了提高数据库并发性能，用更好的方式去处理 "),e("code",[_._v("读-写冲突")]),_._v(" ，做到即使有读写冲突时，也能做到 "),e("code",[_._v("不加锁")]),_._v(" ， "),e("code",[_._v("非阻塞并发读")]),_._v(" ，而这个读指的就是 "),e("code",[_._v("快照读")]),_._v(" , 而非 "),e("code",[_._v("当前读")]),_._v(" 。")]),_._v(" "),e("p",[_._v("当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用"),e("code",[_._v("乐观锁")]),_._v("思想的一种方式。")]),_._v(" "),e("h3",{attrs:{id:"快照读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快照读"}},[_._v("#")]),_._v(" 快照读")]),_._v(" "),e("p",[_._v("快照读又叫一致性读，读取的是快照数据。"),e("strong",[_._v("不加锁的简单的 SELECT 都属于快照读")]),_._v("，即不加锁的非阻塞读；比如这样：")]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" player "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("WHERE")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br")])]),e("p",[_._v("之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。")]),_._v(" "),e("p",[_._v("既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。")]),_._v(" "),e("p",[_._v("快照读的前提是"),e("strong",[_._v("隔离级别不是串行级别")]),_._v("，串行级别下的快照读会退化成当前读。")]),_._v(" "),e("h3",{attrs:{id:"当前读"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#当前读"}},[_._v("#")]),_._v(" 当前读")]),_._v(" "),e("p",[_._v("当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行"),e("code",[_._v("加锁")]),_._v("。加锁的 SELECT，或者对数据进行"),e("strong",[_._v("增删改")]),_._v("都会进行"),e("strong",[_._v("当前读")]),_._v("。比如：")]),_._v(" "),e("div",{staticClass:"language-sql line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" student "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("LOCK")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("IN")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SHARE")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("MODE")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 共享锁")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" student "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FOR")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("UPDATE")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 排他锁")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("INSERT")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("INTO")]),_._v(" student "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("values")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 排他锁")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("DELETE")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" student "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("WHERE")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 排他锁")]),_._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("UPDATE")]),_._v(" student "),e("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SET")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),_._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 排他锁")]),_._v("\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br")])]),e("h2",{attrs:{id:"undo-log-版本链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#undo-log-版本链"}},[_._v("#")]),_._v(" Undo Log 版本链")]),_._v(" "),e("p",[_._v("对于使用 "),e("code",[_._v("InnoDB")]),_._v(" 存储引擎的表来说，它的聚簇索引记录中都包含两个必 要的隐藏列。")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("trx_id")]),_._v(" ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 "),e("code",[_._v("事务id")]),_._v(" 赋值给 "),e("code",[_._v("trx_id")]),_._v(" 隐藏列。")]),_._v(" "),e("li",[e("code",[_._v("roll_pointer")]),_._v(" ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 "),e("code",[_._v("undo日志")]),_._v(" 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。")])]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-9.png",alt:"mysql-9"}})]),_._v(" "),e("blockquote",[e("p",[_._v("insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。")])]),_._v(" "),e("p",[_._v("每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个 roll_pointer 属性 （ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志 都连起来，串成一个链表：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/assets/img/mysql-10.png",alt:"mysql-10"}})]),_._v(" "),e("p",[_._v("对该记录每次更新后，都会将旧值放到一条 "),e("code",[_._v("undo日志")]),_._v(" 中，就算是该记录的一个旧版本，随着更新次数 的增多，所有的版本都会被 "),e("code",[_._v("roll_pointer")]),_._v(" 属性连接成一个链表，我们把这个链表称之为 "),e("code",[_._v("版本链")]),_._v(" ，版本链的头节点就是当前记录最新的值。")]),_._v(" "),e("p",[_._v("每个版本中还包含生成该版本时对应的 "),e("code",[_._v("事务id")]),_._v(" 。")]),_._v(" "),e("h2",{attrs:{id:"readview"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#readview"}},[_._v("#")]),_._v(" ReadView")]),_._v(" "),e("p",[_._v("MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。")]),_._v(" "),e("h3",{attrs:{id:"readview-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#readview-是什么"}},[_._v("#")]),_._v(" ReadView 是什么")]),_._v(" "),e("p",[e("code",[_._v("ReadView")]),_._v(" 其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行，且还没有提交。(当前系统中还有哪些活跃的读写事务)")]),_._v(" "),e("h3",{attrs:{id:"设计思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计思路"}},[_._v("#")]),_._v(" 设计思路")]),_._v(" "),e("p",[_._v("使用 "),e("code",[_._v("READ UNCOMMITTED")]),_._v(" 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录 的最新版本就好了。")]),_._v(" "),e("p",[_._v("使用 "),e("code",[_._v("SERIALIZABLE")]),_._v(" 隔离级别的事务，"),e("code",[_._v("InnoDB")]),_._v("规定使用加锁的方式来访问记录。")]),_._v(" "),e("p",[_._v("使用 "),e("code",[_._v("READ COMMITTED")]),_._v(" 和 "),e("code",[_._v("REPEATABLE READ")]),_._v(" 隔离级别的事务，都必须保证读到 已经提交了的 事务修改 过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问 就是需要判断一下版本链中的哪个版本是当前事务可见的，这是"),e("code",[_._v("ReadView")]),_._v("要解决的主要问题。")]),_._v(" "),e("p",[_._v("这个"),e("code",[_._v("ReadView")]),_._v("中主要包含4个比较重要的内容，分别如下：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("creator_trx_id")]),_._v(" ，创建这个 "),e("code",[_._v("ReadView")]),_._v(" 的事务 ID。")])]),_._v(" "),e("blockquote",[e("p",[_._v("说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为 事务分配事务id，否则在一个只读事务中的事务id值都默认为0。")])]),_._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("code",[_._v("trx_ids")]),_._v(" ，表示在生成"),e("code",[_._v("ReadView")]),_._v("时当前系统中活跃的读写事务的 "),e("code",[_._v("事务id列表")]),_._v(" 。")]),_._v(" "),e("li",[e("code",[_._v("up_limit_id")]),_._v(" ，活跃的事务中最小的事务 ID。")]),_._v(" "),e("li",[e("code",[_._v("low_limit_id")]),_._v(" ，表示生成"),e("code",[_._v("ReadView")]),_._v("时系统中应该分配给下一个事务的 id 值。"),e("code",[_._v("low_limit_id")]),_._v(" 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。")])]),_._v(" "),e("blockquote",[e("p",[_._v("注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。")])]),_._v(" "),e("h3",{attrs:{id:"readview规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#readview规则"}},[_._v("#")]),_._v(" ReadView规则")]),_._v(" "),e("p",[_._v("有了这个"),e("code",[_._v("ReadView")]),_._v("，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。")]),_._v(" "),e("ul",[e("li",[_._v("如果被访问版本的"),e("code",[_._v("trx_id")]),_._v("属性值与"),e("code",[_._v("ReadView")]),_._v("中的 "),e("code",[_._v("creator_trx_id")]),_._v(" 值相同，意味着当前事务在访问 它自己修改过的记录，所以该版本可以被当前事务访问。")]),_._v(" "),e("li",[_._v("如果被访问版本的"),e("code",[_._v("trx_id")]),_._v("属性值小于"),e("code",[_._v("ReadView")]),_._v("中的 "),e("code",[_._v("up_limit_id")]),_._v(" 值，表明生成该版本的事务在当前事务生成"),e("code",[_._v("ReadView")]),_._v("前已经提交，所以该版本可以被当前事务访问。")]),_._v(" "),e("li",[_._v("如果被访问版本的"),e("code",[_._v("trx_id")]),_._v("属性值大于或等于"),e("code",[_._v("ReadView")]),_._v("中的 "),e("code",[_._v("low_limit_id")]),_._v(" 值，表明生成该版本的事 务在当前事务生成"),e("code",[_._v("ReadView")]),_._v("后才开启，所以该版本不可以被当前事务访问。")]),_._v(" "),e("li",[_._v("如果被访问版本的"),e("code",[_._v("trx_id")]),_._v("属性值在"),e("code",[_._v("ReadView")]),_._v("的 "),e("code",[_._v("up_limit_id")]),_._v(" 和 "),e("code",[_._v("low_limit_id")]),_._v(" 之间，那就需要判 断一下"),e("code",[_._v("trx_id")]),_._v("属性值是不是在 "),e("code",[_._v("trx_ids")]),_._v(" 列表中。\n"),e("ul",[e("li",[_._v("如果在，说明创建"),e("code",[_._v("ReadView")]),_._v("时生成该版本的事务还是活跃的，该版本不可以被访问。")]),_._v(" "),e("li",[_._v("如果不在，说明创建"),e("code",[_._v("ReadView")]),_._v("时生成该版本的事务已经被提交，该版本可以被访问。")])])])]),_._v(" "),e("h2",{attrs:{id:"mvcc整体操作流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvcc整体操作流程"}},[_._v("#")]),_._v(" MVCC整体操作流程")]),_._v(" "),e("p",[_._v("当查询一条记录的时候，系统如何通过MVCC找到它：")]),_._v(" "),e("ol",[e("li",[_._v("首先获取事务自己的版本号，也就是事务 ID；")]),_._v(" "),e("li",[_._v("获取 ReadView；")]),_._v(" "),e("li",[_._v("查询得到的数据，然后与 ReadView 中的事务版本号进行比较；")]),_._v(" "),e("li",[_._v("如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；")]),_._v(" "),e("li",[_._v("最后返回符合规则的数据。")])]),_._v(" "),e("p",[_._v("在隔离级别为读已提交（"),e("code",[_._v("Read Committed")]),_._v("）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。")]),_._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),e("p",[_._v("这里介绍了 "),e("code",[_._v("MVCC")]),_._v(" 在 "),e("code",[_._v("READ COMMITTD")]),_._v(" 、 "),e("code",[_._v("REPEATABLE READ")]),_._v(" 这两种隔离级别的事务在执行快照读操作时 访问记录的版本链的过程。这样使不同事务的 "),e("code",[_._v("读-写")]),_._v(" 、 "),e("code",[_._v("写-读")]),_._v(" 操作并发执行，从而提升系统性能。")]),_._v(" "),e("p",[_._v("核心点在于 "),e("code",[_._v("ReadView")]),_._v(" 的原理， "),e("code",[_._v("READ COMMITTD")]),_._v(" 、 "),e("code",[_._v("REPEATABLE READ")]),_._v(" 这两个隔离级别的一个很大不同 就是生成"),e("code",[_._v("ReadView")]),_._v("的时机不同：")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("READ COMMITTD")]),_._v(" 在每一次进行普通SELECT操作前都会生成一个"),e("code",[_._v("ReadView")])]),_._v(" "),e("li",[e("code",[_._v("REPEATABLE READ")]),_._v(" 只在第一次进行普通SELECT操作前生成一个"),e("code",[_._v("ReadView")]),_._v("，之后的查询操作都重复 使用这个"),e("code",[_._v("ReadView")]),_._v("就好了。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);